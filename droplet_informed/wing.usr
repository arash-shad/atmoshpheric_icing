#include "PPICLF_USER.h"
#include "PPICLF_STD.h"

#define IOPART uparam(1)                         /* IOSTEP FOR PARTICLES */
#define npart_inj   uparam(2)
#define usr_endinj  uparam(3)
#define ux_inf  uparam(4)
#define uy_inf  uparam(5)
#define uz_inf  uparam(6)
#define t_inf  uparam(7)
#define t_wall  uparam(8)

c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      udiff  = 0
      utrans = 0
 
      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ie = gllel(ieg)


      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'NEKUSE'
      include 'TOTAL' 

      integer e
      e = gllel(ieg)

      ux    =  ux_inf
      uy    =  uy_inf
      uz    =  uz_inf
      temp  =  t_inf
     
      if (boundaryID(iside,e).eq.13) then   ! airfoil surface
         temp = t_wall
      endif 


      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux    =  ux_inf
      uy    =  uy_inf
      uz    =  uz_inf
      temp  =  t_inf


      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'

      call setbc(10,1,'v  ') ! set inlet to 'v' for field 1
      call setbc(10,2,'t  ') ! set inlet to 't' for field 2
      call setbc(11,1,'O  ') ! set outlet to 'O'
      call setbc(12,1,'ON ') ! set free_wall to 'ON'
      call setbc(13,1,'W  ') ! Set airfoil to 'W' for field 1
      call setbc(13,2,'t  ') ! Set airfoil to 't' for field 2
      call setbc(16,1,'E  ') ! Set Interior

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

c     ############################################################
c     PPICLF

      integer i,j,k

      integer*4 ndiam
      parameter(ndiam = 8)  
      real*8 rhop, dp(ndiam)
      common /dpinfo/ dp, rhop
      data rhop /1000.0/         
      data dp /1.0d-6,5.0d-6,13.0d-6,18d-6
     >        ,29.0d-6,48.0d-6,97.0d-6,160.0d-6/

      real*8 dpmin
      common /dpm/ dpmin

      real*8 rmu,rhof,rg
      common /parameters/ rmu,rhof,rg

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      real*8 y(PPICLF_LRS    , PPICLF_LPART) ! Normal ordering
      real*8 rprop(PPICLF_LRP, PPICLF_LPART) ! Normal ordering

c      real :: dummy_y(1,1), dummy_rprop(1,1)

      real*8 rlz,rrz,dum1,dum2
      common /domainsize/ rlz,rrz

      integer*4 imethod,iendian,npart

      real*8 rdum, ran2
      external ran2

      real*8 y_out(PPICLF_LRS         , PPICLF_LPART) ! Normal ordering
      real*8 rprop_out(PPICLF_LRP + 1 , PPICLF_LPART) ! Normal ordering
      integer*4 iprop_out(5  , PPICLF_LPART)          ! Normal ordering
      integer*4 npart_out
      common /outlet/ y_out,rprop_out,iprop_out,npart_out

      ! Langevin
      real*8 lan_c0,lan_cy,lan_cs,lan_S,lan_cg
      real*8 lan_gij,lan_cw,lan_e,f_w
      common /langevin/ lan_c0,lan_cy,lan_cs,lan_S,
     >              lan_cg,lan_gij,lan_cw,lan_e,f_w

c     ############################################################
      ! Zero all arrays to track outlet particles
      npart_out = 0
      do i=1,PPICLF_LPART

        do j=1,PPICLF_LRS
          y_out(j,i) = 0.0
        enddo

        do j=1,PPICLF_LRS+1
          rprop_out(j,i) = 0.0
        enddo

        do j=1,5
          iprop_out(j,i) = 0.0
        enddo

      enddo

c     ############################################################ 
      ! Pass to library to Init MPI
      call ppiclf_comm_InitMPI(nekcomm,
     >                         nid    , ! nid already defined in Nek5000
     >                         np     ) ! np already defined in Nek


c     USER DEFINED PARAMETERS
      ! Set initial conditions and parameters for particles
      imethod = 1
      ndim    = 3
      iendian = 0
      npart   = 0 ! NUMBER OF PARTICLES PER RANK PER DIAMETER (NTOT=npart*size(dp)*np )
      dpmin   = 1.0d-7

      ! Domain size
      rlz     =  0.0d0
      rrz     =  0.1d0

      ! Fluid and physics parameters
      rhof = param(1)
      rmu  = param(2)
      rg   = -9.8

      ! Langevin parameters
      lan_c0  = 2.1d0
      lan_cy  = 0.039
      lan_cs  = 0.18
      lan_S   = 10.0    ! constant strain rate
      lan_e   = 0.001   ! constant dissipation rate
      f_w     = 1.0d0
      lan_cg=(5.d-1+7.5d-1*lan_c0)*(lan_S*lan_cs**2)/(2.d0*lan_cy)

      call ppiclf_solve_InitParticle(imethod   ,
     >                               ndim      ,
     >                               iendian   ,
     >                               npart     ,
     >                               y(1,1)    ,
     >                               rprop(1,1))

      ! Specify Overlap Mesh
      call ppiclf_comm_InitOverlapMesh(nelt,lx1,ly1,lz1,xm1,ym1,zm1)

      ! Specify neighbor bin size
      call ppiclf_solve_InitNeighborBin(dp)

      call ppiclf_solve_InitPeriodicZ(rlz, rrz)


      return
      end

c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
      include 'PPICLF'

c     ############################################################
c     PPICLF
      real*8 y_out(PPICLF_LRS, PPICLF_LPART)          ! Normal ordering
      real*8 rprop_out(PPICLF_LRP + 1 , PPICLF_LPART) ! Normal ordering
      integer*4 iprop_out(5  , PPICLF_LPART)          ! Normal ordering
      integer*4 npart_out
      common /outlet/ y_out,rprop_out,iprop_out,npart_out

      !Particle Injection
      real*8 y(PPICLF_LRS    , PPICLF_LPART) ! Normal ordering
      real*8 rprop(PPICLF_LRP, PPICLF_LPART) ! Normal ordering
      real*8 npart

      integer i,j,n

c     ############################################################
c     PPICLF
c     PARTICLE INJECTION AT INLET - Arash 12/19/2022
      !Conditions: 1) t = time of sampling  2)t>=0
      ! 3) t < t_{end of injection}

      if ((istep.gt.0).and.
     >    (time.le.usr_endinj)) then
         call my_place_particle(npart,y,rprop) ! All outputs
         ! Add them into solver
         call ppiclf_solve_AddParticles(npart,y,rprop) ! All inputs
      endif

c     ---------------------------------------------
c     Interpolate fields to particle positions
      call ppiclf_solve_InterpFieldUser(PPICLF_R_JUX,vx(1,1,1,1))
      call ppiclf_solve_InterpFieldUser(PPICLF_R_JUY,vy(1,1,1,1))
      call ppiclf_solve_InterpFieldUser(PPICLF_R_JUZ,vz(1,1,1,1))

c     ------------------------------------------
c     INTEGRATE PARTICLES
      call ppiclf_solve_IntegrateParticle(istep ,
     >                               INT(IOPART),
     >                                    dt    ,
     >                                    time  )

c    -------------------------------------------
c     OUTPUT PAROUT FILES
      if (ppiclf_iostep .gt.0)then
       if (mod(ppiclf_cycle,ppiclf_iostep) .eq. 0) then
        call ppiclf_io_WriteParticleOutletVTU('parout')

        if (.true.) then
          npart_out = 0 !outputs particles out only in between [iostep-1,iostep]
          do i=1,PPICLF_LPART  ! Maximum number of particles per rank
            do j=1,PPICLF_LRS  ! Number of equations solved per particle.
              y_out(j,i) = 0.0
            enddo
            do j=1,PPICLF_LRP+1
              rprop_out(j,i) = 0.0
            enddo
            do j=1,5
              iprop_out(j,i) = 0.0
            enddo
          enddo
        endif

       endif
      endif

c      if (mod(ISTEP,5000).eq.0) call hpts
c      if (istep.eq.5000) call hpts()

      call dist_p

      return
      end

c------------------------------------------------------------
      subroutine dist_p
      include 'SIZE'
      include 'TOTAL'
      include 'PPICLF'

      real xp(PPICLF_LPART)
      real yp(PPICLF_LPART)
      real zp(PPICLF_LPART)

      integer rcode(PPICLF_LPART)
      integer elid(PPICLF_LPART)
      integer proc(PPICLF_LPART)

      real rst(PPICLF_LPART*ldim)
      real dist(PPICLF_LPART)
      real outp(PPICLF_LPART)

      integer handle,icalld,flag
      save handle,icalld
      data icalld /0.0/

      real cdist(lx1,ly1,lz1,lelt)
      save cdist

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal


      ! findpts setup
      tol     = 5e-13
      bb_t    = 0.05
      npt_max = 256
      ndum    = lx1*ly1*lz1*lelt

      if (icalld.eq.0) then
        call cheap_dist(cdist,1,'W  ')

        call fgslib_findpts_setup(handle
     >                         ,nekcomm,np,ndim
     >                         ,xm1,ym1,zm1
     >                         ,nx1,ny1,nz1,nelt
     >                         ,2*lx1,2*ly1,2*lz1
     >                         ,bb_t
     >                         ,ndum,ndum
     >                         ,npt_max,tol)       
        icalld = 1
      endif

      do i=1,ppiclf_npart
        xp(i) = ppiclf_y(PPICLF_JX,i)
        yp(i) = ppiclf_y(PPICLF_JY,i)
        zp(i) = ppiclf_y(PPICLF_JZ,i)
      enddo

      call fgslib_findpts(handle
     &                  , rcode, 1
     &                  , proc , 1
     &                  , elid , 1
     &                  , rst  , ldim
     &                  , dist , 1
     &                  , xp   , 1
     &                  , yp   , 1
     &                  , zp   , 1
     &                  ,ppiclf_npart)

      call fgslib_findpts_eval(handle
     &                  , outp   ,1
     &                  , rcode  ,1
     &                  , proc   ,1
     &                  , elid   ,1
     &                  , rst    ,ldim
     &                  , ppiclf_npart ,cdist)

c     ######################################
c     REMOVE PARTICLES

      xmin= 0.10
      xmax= 0.20
      ymax= 0.05

      do i=1,ppiclf_npart
        rp = ppiclf_rprop(PPICLF_R_JDP,i)/2
        if (outp(i).le.rp) then
          call ppiclf_solve_MarkForRemoval(i)
          call ppiclf_solve_SaveRemoved(i)
        endif
        if (yp(i).gt.ymax .and. xp(i).gt.xmin) then
           call ppiclf_solve_MarkForRemoval(i)
        endif
        if (yp(i).le.ymax .and. xp(i).gt.xmax) then
           call ppiclf_solve_MarkForRemoval(i)
        endif

      enddo

      call ppiclf_solve_RemoveParticle

      return
      end

c----------------------------------------------------------------------------------------
c     Particle Injection at inlet
      subroutine my_place_particle(k,y,rprop)
      include 'SIZE'
      include 'TOTAL'

      integer i,j,k,k2
      real*8 y(PPICLF_LRS    , PPICLF_LPART) ! Normal ordering
      real*8 rprop(PPICLF_LRP, PPICLF_LPART) ! Normal ordering

      real*8 rlz,rrz
      common /domainsize/ rlz,rrz

      real*8 rmu,rhof,rg
      common /parameters/ rmu,rhof,rg

      integer*4 ndiam
      parameter(ndiam=8)
      real*8 rhop, dp(ndiam)
      common /dpinfo/ dp, rhop


      k=0
      k2 = 0
      dp_sld  = 40.0d-6

      if (nid.eq.0) then
        k = 0

        do j=1,ndiam       
         do i=1,npart_inj
            k= k+1

            rprop(PPICLF_R_JRHOP,k) = rhop
            rprop(PPICLF_R_JDP  ,k) = dp(j)
            rprop(PPICLF_R_JVOLP,k) = pi/6.0D0*dp(j)**3
            rprop(PPICLF_R_JVS  ,k) = rhop*dp(j)**2*rg
     >                               /18./rmu

            if (dp(j) .lt. dp_sld) then
             y(PPICLF_JX,k)  = -0.30 + 0.03*ran2(2)
             y(PPICLF_JY,k)  =  0.08 - 0.05*ran2(2)
             y(PPICLF_JZ,k)  =  rlz + (rrz-rlz)*ran2(2)
            else
             y(PPICLF_JX,k)  = -0.30 + 0.03*ran2(2)
             y(PPICLF_JY,k)  =  0.10 - 0.08*ran2(2)
             y(PPICLF_JZ,k)  =  rlz + (rrz-rlz)*ran2(2)
            endif

            y(PPICLF_JVX,k) = ux_inf
            y(PPICLF_JVY,k) = uy_inf
            y(PPICLF_JVZ,k) = uz_inf


         enddo
        enddo
      endif
       
      return
      end

c-----------------------------------------------------------------------

      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
      REAL ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     $        IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,
     $        IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
c Long period (> 2 ! 1018 ) random number generator of Lâ€™Ecuyer with
c Bays-Durham shuffle and added safeguards. Returns a uniform random deviate
c between 0.0 and 1.0 (exclusive of the endpoint values).
c Call with idum a negative integer to initialize; thereafter, do not alter
c idum between successive deviates in a sequence. RNMX should approximate the
c largest floating value that is less than 1.
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then
         idum1=max(-idum,1)
         idum2=idum1
         do j=NTAB+8,1,-1
            k=idum1/IQ1
            idum1=IA1*(idum1-k*IQ1)-k*IR1
            if (idum1.lt.0) idum1=idum1+IM1
            if (j.le.NTAB) iv(j)=idum1
         enddo
         iy=iv(1)
      endif
      k=idum1/IQ1
      idum1=IA1*(idum1-k*IQ1)-k*IR1
      if (idum1.lt.0) idum1=idum1+IM1
      k=idum2/IQ2
      idum2=IA2*(idum2-k*IQ2)-k*IR2
      if (idum2.lt.0) idum2=idum2+IM2
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum1
      if(iy.lt.1)iy=iy+IMM1
      ran2=min(AM*iy,RNMX)
      return
      END
